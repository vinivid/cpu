library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity control_unit is
    port (
        instruction : in STD_LOGIC_VECTOR (7 downto 0);
        clk : in STD_LOGIC;
        control_mask : out STD_LOGIC_VECTOR (17 downto 0)
    );
end entity control_unit;

architecture Behaviour of control_unit is
    constant ADD   : STD_LOGIC_VECTOR (3 downto 0) := "0000";
    constant SUB   : STD_LOGIC_VECTOR (3 downto 0) := "0001";
    constant ANDD  : STD_LOGIC_VECTOR (3 downto 0) := "0010";
    constant ORR   : STD_LOGIC_VECTOR (3 downto 0) := "0011";
    constant NOTT  : STD_LOGIC_VECTOR (3 downto 0) := "0100";
    constant CMP   : STD_LOGIC_VECTOR (3 downto 0) := "0101";
    constant JMP   : STD_LOGIC_VECTOR (3 downto 0) := "0110";
    constant JEQ   : STD_LOGIC_VECTOR (3 downto 0) := "0111";
    constant JGR   : STD_LOGIC_VECTOR (3 downto 0) := "1000";
    constant LOAD  : STD_LOGIC_VECTOR (3 downto 0) := "1001";
    constant STORE : STD_LOGIC_VECTOR (3 downto 0) := "1010";
    constant MOV   : STD_LOGIC_VECTOR (3 downto 0) := "1011";
    constant INN   : STD_LOGIC_VECTOR (3 downto 0) := "1100";
    constant OUTT  : STD_LOGIC_VECTOR (3 downto 0) := "1101";
    constant WAITT : STD_LOGIC_VECTOR (3 downto 0) := "1110";

    component decoder is
        port (
            instruction : in STD_LOGIC_VECTOR (7 downto 0);
            op : out STD_LOGIC_VECTOR (3 downto 0);
            reg_x1 : out STD_LOGIC_VECTOR (1 downto 0);
            reg_x2 : out STD_LOGIC_VECTOR (1 downto 0)
        );
    end component;

    signal op : STD_LOGIC_VECTOR (3 downto 0);

    signal bitmask : STD_LOGIC_VECTOR (14 downto 0);
    --Os e's representams se uma registradora estatra abilitada
    --Os enables tabém serão a forma de de controlar quem recebe dado ou não numa operação de mov por exemple
    alias eA : STD_LOGIC is bitmask(14);
    alias eB : STD_LOGIC is bitmask(13);
    alias eR : STD_LOGIC is bitmask(12);

    --Enable das registradoras de flags
    alias eF : STD_LOGIC is bitmask(11);

    --Memory write enable é o bit q permite a ram ser escrita naquela endereço
    alias Mwe : STD_LOGIC is bitmask(10);

    --É um bit q significa se a memoria sera endereçada pelo program counter (0) ou pela propria memória(1)
    alias addr : STD_LOGIC is bitmask(9);

    --Os i's representam se a registradora estara lendo de outra outra registradora (0) ou do input (1)
    alias iA : STD_LOGIC is bitmask(8);
    alias iB : STD_LOGIC is bitmask(7);
    --O iR é um pouco diferente pois nele também se abilita ler da ula (10)
    alias iR : STD_LOGIC is bitmask(6 downto 5);

    --Sao os dois bits que representam qual registradora q deve ser selecionada em uma instrução em que xA é a operadora a a ser selecionada e
    --xB a segunda registradora (nas operaçoes que podem receber duas)
    alias xA : STD_LOGIC is bitmask(4 downto 3);
    alias xB : STD_LOGIC is bitmask(2 downto 1);

    --É o bit q representa q é um immidiate e tem q ir para o próximo endereço da memoria para saber o valor a somar
    alias imm : STD_LOGIC is bitmask(0);

    --O memory read enable esta implicitamente em selecionar a xB como 11 para q ele selecione q a registradora 
begin
    
    decoder_inst: decoder
     port map(
        instruction => instruction,
        op => op,
        reg_x1 => xA,
        reg_x2 => xB
    );
    
    --Em qualquer uma das operações da linha 1 (começando do when ) abaixo dessa não sera necessario abilitar a registradora pois ela não vai receber nada
    --A segunda linha representa as operações em que a registradora recebe algo LOAD STORE MOV IN
    --A terceira é o default
    eA <= '0' when (op = JMP or op = JEQ or op = JGR or op = WAITT or op = ADD or op = SUB or op = ANDD or op = ORR or op = NOTT or op = CMP or op = OUTT) else 
          '1' when xA = "00" else
          '0';
    
    --Essa registradora é igual a A
    eB <= '0' when (op = JMP or op = JEQ or op = JGR or op = WAITT or op = ADD or op = SUB or op = ANDD or op = ORR or op = NOTT or op = CMP or op = OUTT) else 
        '1' when xA = "01" else
        '0';
    
    --A difereça da reg R para a A e B é que ela sempre recebera quando for operação da ULA q n seja o CMP
    --Um detalhe importante é de que a registradora de resultado não atualiza quando é um CMP, só a registradora de flags
    --Na terceira linha novamente estara as operações de movimentação
    eR <= '0' when (op = JMP or op = JEQ or op = JGR or op = WAITT or op = CMP or op = OUTT) else
          '1' when (op = ADD or op = SUB or op = ANDD or op = ORR or op = NOTT) else
          '1' when xA = "10" else 
          '0';

    --As registradoras de flag só estarão ativadas quando for uma operação de ula ou uma operação de comparação
    eF <= '1' when (op = ADD or op = SUB or op = ANDD or op = ORR or op = NOTT or op = CMP) else 
          '0';    
    
    --Só se escrevera numa posição da memória quando for load
    Mwe <= '1' when op = LOAD else 
           '0'; 
    
    addr <= '1' when (op = LOAD or op = STORE) else 
            '0';
    
    --Para a iB elas só receberam input qnd for a operçao for IN se não elas sempre receberam de outra registradora
    --TODO: colocar iA e iB para um unico sinal
    iA <= '1' when op = INN else 
          '0';
    
    iB <= '1' when op = INN else 
          '0';
    
    --iR só recebera input quando for 01 recebera o valor da ula quando for 10 e de resto sempre recebera o valor de outra registradora
    iR <= "01" when op = INN else
          "10" when (op = ADD or op = SUB or op = ANDD or op = ORR or op = NOTT) else 
          "00"; 
        
    --Só sera um valor imediato quando xB for 11 pois foi o especificado pela ISA
    imm <= '1' when xB = "11" else 
           '0';

    process (clk)
        type cpu_stages is (FETCH, DECODE_IMIDIATE, DECODE_LOAD_STORE, EXECUTE);
        variable 
    begin
        if rising_edge(clk) then

        end if;    
    end process;

end architecture Behaviour;